#!/bin/bash

# ==============================================================================
#  Search & Destroy (snd) - Interactive Edition (for macOS)
#  Copyright (c) 2026 Yu-Sung Chang | MIT License
# ==============================================================================

VERSION="@@VERSION@@"

ME=$(basename "$0")
IGNORE=""
PRUNE_DIRS=()
TYPE=""
DEBUG=false

trap 'kill $(jobs -p) 2>/dev/null' EXIT INT TERM

usage() {
    cat << EOF >&2
$ME - Search and destroy files or directories interactively (for macOS).
Copyright (c) 2026 Yu-Sung Chang. Released under the MIT License.

Usage: $ME [OPTIONS] <STRING>

Arguments:
  STRING       String to match (e.g. "microgsoft" creates the pattern "*microsoft*")
  
Options:
  -t TYPE       Search type: f (file), d (directory) [Default: both]
  -d            Dry run mode (show what would be deleted without deleting)
  -i STRING     Ignore matches containing this string (e.g. "com.apple")
  -p DIR        Prune a directory (e.g. "CloudStorage"). Repeatable: -p dir1 -p dir2
  -h            Display this help and exit
  -v            Display version and exit

Interface Controls:
  Arrows       Move selection
  TAB          Select multiple items for deletion
  ENTER        Confirm selection and delete
  ESC          Quit without deleting

Example:
  $ME microsoft                # Find files AND directories containing 'microsoft'.
  $ME -t d -i apple plugin     # Find directories containing 'plugin' but not 'apple'.
  $ME -p CloudStorage adobe    # Find files and directories containing 'adobe' but not in CloudStorage directory.
EOF
}

# --- Parse Flags ---
while getopts "t:i:p:dhv" opt; do
    case "$opt" in
        t) TYPE=$OPTARG ;;
        i) IGNORE=$OPTARG ;;
        p) PRUNE_DIRS+=("$OPTARG") ;;
        d) DEBUG=true ;;
        h) usage; exit 0 ;;
        v) echo "$VERSION"; exit 0 ;;
        *) usage; exit 1 ;;
    esac
done

# Shift the arguments so that $1 and $2 become the Pattern and Type
shift $((OPTIND-1))
PATTERN=$1

# --- Validate Input ---
if [[ -z "$PATTERN" ]]; then
    usage; exit 1
fi

# Ensure fzf is installed
if ! command -v fzf &> /dev/null; then
    echo "$ME: fzf not found. Please run 'brew install fzf' first." >&2
    exit 1
fi

# --- Construct Find Command ---
FIND_CMD=(find .)

# 1. Add Pruning (Must be first)
if [[ ${#PRUNE_DIRS[@]} -gt 0 ]]; then
    for dir in "${PRUNE_DIRS[@]}"; do
        FIND_CMD+=(-path "*/$dir" -prune -o)
    done
fi

# 2. Add Name Pattern
FIND_CMD+=(\() # Start a new group for the name pattern
FIND_CMD+=(-iname "*$PATTERN*")

# 3. Add Type (f, d, or both)
if [[ "$TYPE" == "f" || "$TYPE" == "d" ]]; then
    FIND_CMD+=(-type "$TYPE")
else
    # Logic for "both" requires an OR group in find
    FIND_CMD+=( \( -type f -o -type d \) )
fi

# 4. Add Ignore
[[ -n "$IGNORE" ]] && FIND_CMD+=(-not -iname "*$IGNORE*")

# 5. Finish the command
FIND_CMD+=(\))
FIND_CMD+=(-print0)

# --- Select Targets  ---
echo "$ME: Searching... (Skipping: ${PRUNE_DIRS[*]:-None})"

TARGETS=$(
    while IFS= read -r -d '' item; do
        [[ -d "$item" ]] && label="D" || label="F"
        size=$(du -sh "$item" 2>/dev/null | cut -f1)
        last_mod=$(stat -f "%Sm" -t "%Y-%m-%d" "$item" 2>/dev/null)
        printf "[%s|%4s|%10s]\t%s\n" "$label" "${size:-0B}" "${last_mod:-Unknown}" "$item"
    done < <("${FIND_CMD[@]}" 2>/dev/null) | \
    fzf -m \
        --delimiter=$'\t' \
        --with-nth=1,2 \
        --header="TAB: Select | ENTER: Confirm selection | ESC: Quit" \
        --prompt="Search » " \
        --height=50% \
        --reverse \
        --border
)

if [[ -z "$TARGETS" ]]; then
    echo "Nothing selected. Exiting."
    exit 0
fi

# Clean the selection (strip the size/date prefix for the rm command)
CLEAN_TARGETS=$(echo "$TARGETS" | cut -f2)
COUNT=$(echo "$CLEAN_TARGETS" | wc -l | xargs)

# --- Confirm and Delete ---
echo ""
echo "----------------------------------------------------"
echo "THE FOLLOWING $COUNT ITEMS WILL BE DELETED:"
echo "$CLEAN_TARGETS"
echo "----------------------------------------------------"
echo ""

if [[ "$DEBUG" == true ]]; then
    echo "*** DRY RUN — nothing will actually be deleted ***"
fi
read -p "$ME: Are you absolutely sure? [y/N] " confirm

if [[ "$confirm" =~ ^[Yy]$ ]]; then
    echo "$CLEAN_TARGETS" | while read -r line; do
        if [[ "$DEBUG" == true ]]; then
            echo "[DRY RUN] Would delete: $line"
        else
            rm -rf "$line"
            echo "Deleted: $line"
        fi
    done
    echo "Cleanup complete."
else
    echo "Operation aborted. Nothing was deleted."
fi
